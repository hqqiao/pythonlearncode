# filter
'''
# Python内建的filter()函数用于过滤序列。
# 和map()类似，filter(function,list)也接收一个函数和一个序列。
# 和map()不同的是，filter()把传入的函数依次作用于每个元素，
然后根据返回值是True还是False决定保留还是丢弃该元素。

# 需要注意filter()函数返回的是一个Iterator迭代器，也就是一个惰性序列，
# 所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。

filter()的作用是从一个序列中筛出符合条件的元素,使用惰性计算，
只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素
'''
# 例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
def is_odd(n):
    return n % 2 == 1
print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))
print(list(filter(is_odd,[1,2,3])))
# 把一个序列中的空字符串删掉
def not_empty(s):
    return s and s.strip()
print((not_empty(' ty o p ')))     #ty o p    移除了首尾的空字符
print(not_empty(None))
print(list(filter(not_empty, [None])))
print(list(filter(not_empty, ['A', '', 'B', None, 'C', '  '])))
# 结果: ['A', 'B', 'C']

'''
# Python strip()方法
# 描述
# Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
# 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。
# strip()方法语法： str.strip([chars]);
# 参数 chars -- 移除字符串头尾指定的字符序列。
# 返回值 返回移除字符串头尾指定的字符以后，生成的新字符串。
'''
# 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。
# 注意到filter()函数返回的是一个Iterator迭代器，也就是一个惰性序列，
# 所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。
'''
【惰性求值】
在编程语言理论中，惰性求值（英语：Lazy Evaluation），又译为惰性计算、懒惰求值，
也称为传需求调用（call-by-need），目的是最小化计算机要做的工作。
它有两个相关而又有区别的含意，可以表示为“延迟求值”和“最小化求值”。
1.避免不必要的计算，带来性能的提升（最小化求值）。 
对于Python中的条件表达式 if x and y,在x为false的情况下y表达式的值将不再计算。
而对于if x or y，当x的值为true的时候将直接返回，不再计算y的值。
因此编程中可以利用该特性，在 and逻辑中，将小概率发生的条件放在前面或者在or逻辑中，将大概率发生的时间放在前面，有助于性能的提升。
2. 节省空间，使得无线循环的数据结构成为可能（延迟求值）。 
延迟求值特别用于函数式编程语言中。在使用延迟求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。
延迟求值的一个好处是能够建立可计算的无限列表而没有妨碍计算的无限循环或大小问题。
例如，可以建立生成无限斐波那契数列表的函数（经常叫做“流”）。
第n个斐波那契数的计算仅是从这个无限列表上提取出这个元素，它只要求计算这个列表的前n个成员。
【惰性序列】
Python的惰性序列多数指iterator，其特点正如同上文所述，具有惰性计算特点的序列称为惰性序列。 
Python的iterator是一个惰性序列，意思是表达式和变量绑定(比如：调用iter()得到了一个iterator并赋值给一个变量)后不会立即进行求值，
而是当你用到其中某些元素的时候才去求某元素对的值(比如next()访问到某元素才去实际计算某元素的值)。 
惰性是指，你不主动去遍历它，就不会计算其中元素的值。 

【意义】 
一是这样我们就可以实现无限序列的表示，比如全部的自然数(无穷尽)，而不需要真的在内存中计算出所有的自然数(那根本不可能，因为内存也不是无限的)，
而是需要哪个数，计算到哪个数，或者需要哪些数，计算到那些数(比如前1000个)。 
二是在大规模数据处理中起到延迟计算的作用。当你处理大规模数据时，一次性进行处理往往是不方便的。
而惰性序列就可以解决这个问题，它把计算的步骤延迟到了要实际使用该数据的时候。 
惰性序列可以看作是一个”流”，需要的时候从其中取一滴水。

【一句话理解】
迭代器的一个优点就是它不要求你事先准备好整个迭代过程中所有的元素。
迭代器仅仅在迭代至某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。
这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件，或是斐波那契数列等等。
'''



'''
filter求素数（除了2以外，一定是从奇数中寻找）
计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：
首先，列出从2开始的所有自然数，构造一个序列：
2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：
3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：
5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数5，然后用5把序列的5的倍数筛掉：
7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
不断筛下去，就可以得到所有的素数。
'''
# 注意：求素数，除了偶数2以外，一定是从奇数中筛选，所以构造从3开始的奇数序列
# yield 注意这是一个生成器，并且是一个无限序列。
# 3 5 7 9 11 13 15 17 19 21 23 25 ……
def _odd_iter():
    n = 1
    while True:
        n = n+2
        yield n
# 然后定义一个筛选函数：
def _not_divisible(n):
    return lambda x: x % n > 0       # x不是n的倍数

# 最后，定义一个生成器，不断返回下一个素数：

def primes():
    yield 2
    it = _odd_iter()
    # 初始序列 生成器，通过next()获取序列数值 3 5 7 9 11 13 15 17 19 21 23 25 ……
    # generator，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
    while True:
        n = next(it)    # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列

# 这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。

# 由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：

# 打印50以内的素数:
for n in primes():
    if n < 50:
        print(n)
    else:
        break
#注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。

# 作业
# 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：
def is_palindrome(n):
    n = str(n)
    if n == n[::-1]:    # 正序 == 倒序
        return True
    else:
        return False
output = filter(is_palindrome, range(1, 200))
print('1~200:', list(output))
'''
切片操作总结：
# [start:stop:step]
a = [0,1,2,3,4,5,6,7,8,9]
b = a[i:j] 表示复制a[i]到a[j-1]，以生成新的list对象
b = a[1:3] 那么，b的内容是 [1,2]
当i缺省时，默认为0，即 a[:3]相当于 a[0:3]
当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]
当i,j都缺省时，a[:]就相当于完整复制一份a了

b = a[i:j:s]，s表示步进，缺省为1.
a[i:j:1]相当于a[i:j]
当s<0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1
所以a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍,即全部倒序复制
上述例子为 a[-1:-11:-1]
'''
a = [0,1,2,3,4,5,6,7,8,9]
print('a[-1:-11:-1]',a[::-1])
# a[-1:-11:-1] [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

